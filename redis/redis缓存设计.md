# redis缓存设计
```
应该避免 缓存雪崩、缓存击穿、缓存穿透、一致性
这三个问题
```

## 缓存雪崩
```
同一时间大量key过期，导致大量请求打到DB，把数据库压跨，进而系统连锁反应，最终导致系统不可用。
```
对应策略
```
过期时间设置为随机
不设置过期时间，后台线程定期更新
```
## 缓存击穿
```
热点数据突然过期导致,大量请求打到DB
```
对应策略
```
(1)不设置过期时间，后台线程定期更新
(2)加个锁，只允许一个请求访问DB
(3)singleflight,即合并请求，将多个请求合并为一个
```
singleflight原理 
```go
type caller struct{
    result interface{}
    err error
}

func call(key string, f func()(result, error)) {
    mu.Lock()
    defer mu.UnLock()
    if c,ok:=mm[key];ok{
        wg.Wait()
        return c.result, c.err
    }
    mm[key] = &call{}
    wg.Add(1)
    c.result,c.err = f()
    wg.Done()
    return c.result, c.err
}
```
## 缓存穿透
```
即访问的数据即不在缓存，也不在数据库里
一般是非法用户或业务请求不合理 所造成
```
对应策略
```
(1)在api层限制非法ip
(2)在写数据的时候，把key写到布隆过滤器里，查询数据库前，先判断数据在不在
(3)当发现有缓存穿透时，设置一个返回默认值，不让他访问缓存和DB
```
## 缓存数据一致性
缓存不一致是指：DB的值和缓存致不一致(并且一般指不重启的情况，永久不一致)  
问题列表
```
(1)处理写请求时，数据写到数据库后，是更新缓存，还是删除缓存？
(2)处理写请求时，是先删除缓存，再写数据库，还是先写数据库，再删除缓存
(3)先更新数据库，再删除缓存，就能保证一致性吗
```
(1)问题分析
```c
//在两个并发写的情况下，更新缓存有脏数据问题，应该采取删除缓存
如果是采取更新缓存，那么在两个并发写的请求，那么可能缓存到旧值，所以应该采取删除缓存比较合适(get请求的时候，再load到缓存)
```
(2)问题分析
```c
//在并发读写的情况，先删除缓存，会有脏数据，应该采取先更新DB，再删除缓存
如果先删除缓存，再更新数据库，那么在：写请求将缓存删除了(未完成写到DB情况)，此时读请求发现缓存没中，从DB读(旧值)到缓存，此时写请求到DB才完成。
```
(3)问题分析
```c
//即使先更新数据库，再删除缓存，也还是有可能缓存不一致的。
例如:在删除缓存的时候失败(但实际这种情况概率比较小)

//妥协方案
缓存加个过期时间，这样即使不一致，也是某一段小时间

//稳妥方案
(1)加个删除缓存重试策略
(2)订阅mysql binlog日志，有消息时，更新对应的缓存
```