# WO
```
背景
    多人协作，只允许打开一个文件
    打开文件期间，占用锁
sessionLease
    使用setNx实现，只有一个请求获取锁
    使用定期续约锁
        如果续约失败，则关闭文件 和 删除锁
```
# 单节点锁
```
获取锁
    SetNX(ctx,key,value,ttl), value=uuid
删除锁
    用lua脚本，将key和value传进行，并判断value是否相等：
    if get(key) == value {
        return 1
    }
    return 0
为什么 要判断value
    client1 拿锁后，万一哪一个步骤产生了阻塞，等到醒来的时候，去删除锁，而这时锁已径过期了，
    并且是client2拿到，这样就把client2的锁误删除了。
主从节点有下面缺点情况：
    如果client1拿到锁，这时master节点挂了，但锁的数据没同步到从节点上，从节点升级为master，
    client2这时就有可能拿到锁，这就冲突了
```
# 多节点锁，如5个master
```
获取锁
    同样用SetNX向每个节点获取锁，当大于3个的时候，并且耗时未过期，即获取锁的开始时间-当前时间，
    在ttl范围内，那就说明获取锁成功。大概步骤为：
        (1)获取当前时间
        (2)向5个master调用 setnx获取锁
        (3)算出前两步的耗时，并判断是否在有效期内
        (4)如果是在有效期，访问共享资源
删除锁
    需向每个节点删除
    为什么删除需要向每个节点删除呢？
        兼容网络错误情况：
            redis执行setnx成功，但返回结果时，网络遇到有问题。
            这时client是报错的
极端情况分析
    clinet1得到3个master回应成功，但这时候有一个挂了，数据未同步到从节点，马上重启，client2还是有机会获取到锁
    解决方案是
        延迟重启那个节点，等client1锁失效

    在第(3)步之后，发生程序挂起，等它醒来时，锁已过期，这是解决不了的，所有分布式锁都有这个问题。
```
