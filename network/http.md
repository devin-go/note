# http 缓存
强制缓存
```
(1)respone 返回时添加cache-control或expires header，指定过期时间
(2)后续客户端在请求时判断，如果在有效期里，就直接使用缓存的
```
协议缓存
```
(1)服务端response返回时，除了添加强制缓存的header外，还添加一个etag header
(2)客户端再次请求时，优先判断缓存是否过期，如果没过期，则直接使用本地缓存；如果过期了，则带上etag去请求服务端
(3)服务端收到etag，判断etag是否相等，如果相等则返回304状态码，告诉客户端可以使本地缓存；否则返回200状态码和资源内容
```
# http1.1
什么是队头阻塞？
```
(1)在一个长连接里，客户端可以发送多个请求，即客户端在发送完请求A时，不必等请求A的响应，立刻就可以发送请求B
(2)但要求服务端返回必须按顺序返回，即先返回请求A，再返回请求B(如果请求A比较耗时，即使请求B先完成，那要等请求A完成，这就是队头阻塞问题)
```
# https
```
https:http+tls+ca证书
https 除了要三次握手外，还需要tls握手
```
tls握手(RSA算法)
```
(1)tcp三次握手
(2)client hello(随机数，tls版本，密码套件列表)
(3)server hello(随机数，确认tls版本，确认使用的密码套件)
(4)server 发送ca证书给客户端
(5)server done.
(6)客户端使用公钥校验证书，并取出公钥
(7)客户端生成随机数，并用公钥加密发给服务端
(8)服务端用私钥解密，并根据上下文生成会话密钥
(9)客户端根据上下文，生成会话密钥
(10)之后客户与服务端通信都用这个会话密钥加密
```
一些知识
```
tls有多种算法，不同的算法握手流程也不一样。比较常用的算法有两种：RSA和ECDHE
优先使用ECDHE算法
tls1.3已舍弃RSA算法了，默认ECDHE算法了
```
RSA
```c
RSA握手流程比较简单，但不具备“前向安全性”
握手流程比较耗时，需要4个RRT
//前向安全性
即第三方存储了之前的数据包，如果服务端的私密钥泄密了，那么之前的数据都能解密掉
```
tls1.3
```
握手只需要一个rrt，并且安全性更高
```
## https优化方法
会话重用
```c
//session id
客户端与服务端握手后，服务端缓存会话密钥，后面如果客户端再次连接的时候，带上密钥的id（session id）
//session tick
会话密钥不在服务端缓存，而是将会话密钥加密后，交给客户端缓存，客户端再次请求时，带上这个session tick，服务端解密后，就可以获取到上次的会话密钥并检查有效时间，就可以再次通信了
//Pre-shared Key
tls1.3才有，原理和session tick一样，但对于重连做到了0RTT（上面两种都要1RTT）

//注意
会话重用虽然好用，但有重放和前向安全风险
```
# http2
http2的优势
```
(1)压缩header头
(2)使用二进制传输
(3)使用stream传输，多个请求可以并发
(4)服务端主动推送
```
http2队头阻塞
```
http2队头阻塞发生在tcp层：
如一个请求可能有多个数据包，如果数据包1发生了丢失，那么即使后面数据包到达了，也要等数据包1到了，http层才能读取到
```