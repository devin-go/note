# gc版本概括
1.3之前采用标记清除法，整个过程需要STW  
1.5 采用三色标记+插入屏障(gc退出前，栈空间需要STW，不过时间相对很少10~100ms)  
1.8 采用三色标记+混合写屏蔽(几乎不需要STW)

# 三色标记流程
白-->灰-->黑
```
1.从root节点发出，能到达的标记为灰色(注意不是递归，只扫描一层)
2.扫描第一步的灰色对象，将能到达的对象标记为灰色，同时将第一步的灰色对象标记为黑色
3.重复扫描灰色对象，直到没有灰色对象，最后将白色对象(垃圾)清除掉
```
## 没有STW场景
结果：会有有用的对象被清除掉，导致程序出错  
场景如下：  
(1)一个白色对象被一个灰色和黑色对象引用
(2)同时灰色对象删除掉白色对象的引用  
(3)此时有用的白色对象就会被清除掉了(因为没有灰色对象引用或自身不是灰色)
## 引用屏障机制，破坏没有STW场景
### 插入屏障
对象被引用时触发的机制，被引用的对象标记为灰色
```go
B b = new B()
A.p = b
//b 被标记为灰色
```
缺点：gc退出前，栈空间需要STW，具体看1.5
### 删除屏障
删除对象时触发的机制，被删除的对象标记为灰色
```go
A.p = b
A.p = nil
//b被标记为灰色
```
缺点：回收精度不高，b对象仍可活到下一轮gc

# 1.5三色标记+插入屏障
(1)插入屏障只在堆上使用，栈上不使用
(2)当gc结束前，需要STW重新扫描栈空间，将Root节点能到达的统一标记为黑色
(3)将白色垃圾删除掉
## 栈空间需要STW场景
因为栈空间没有启用插入屏障，所以在栈空间上，有可能存在黑色对象引用了白色对象，且这个白色对象没有被灰色对象引用，而堆空间开启了插入屏障则没有这个问题  
虽然在gc结束前在栈空间有STW,但时间很短，只有10~100ms

# 1.8三色标记+混合屏障
结合了插入+删除屏障的优点，无需STW了，具体步骤如下
```
(1)gc将栈root能到达的对象全部标记为黑色
(2)gc期间，栈上new的对象全部为黑色
(3)被删除的对象标记为灰色
(4)被引用的对象标记为灰色
```
注意：  
由(1)和(2)步骤得知，混合屏障在栈上不用开启
但栈空间存在回收精度不高的问题(还好栈空间对象并不是很多)

# 内存分配
使用类似tcmalloc算法，基本解决了内存碎片问题及提高了分配效率
## tcmalloc原理
(1)将内存划分为很多种大小不统一的链表(free list)，如8k大小的组成一个链表，16k大小的组成一个链接，32k...等等  
(2)使用多级缓存，减少锁的冲突：线程缓存-->cpu级缓存-->central cache-->page Heap--->os memory  
[具体原理](https://www.cnblogs.com/jiujuan/p/13869547.html)

# gc优化
如果cpu过高可能是由于gc过于频繁导致的
## 控制gc的参数
```
GOGC
SetMemoryLimit(go 1.19后才有)
```
## GOGC
设置百分比(默认值100%)，以控制GC回收，举个例子，GC回收前占用了100M内存，那么当内存达到200M时，就会触发GC  
### ballast
使用GOGC的特性，如果在程序一启动的时候就申请一块大内存，那么就能减少GC的频率了，例如
```go
func main() {
  ballast := make([]byte, 10*1024*1024*1024) // 10G 
  // do something
  runtime.KeepAlive(ballast)
}
```
### gc tuner
实现了 动态调整GOGC值，降低GC频率的同时，将内存利用得更好，uber提出，但没有开源。可以查看[曹大根据原理实现的](https://github.com/cch123/gogctuner)

## SetMemoryLimit
```
限制程序软内存的大小，使程序使用的内存尽量保持在这个水平，超过的会返回给os，没达到尽量不GC
```